package com.apocscode.mcai.task;

import com.apocscode.mcai.MCAi;
import com.apocscode.mcai.entity.CompanionEntity;
import net.minecraft.core.BlockPos;
import net.minecraft.tags.BlockTags;
import net.minecraft.world.entity.item.ItemEntity;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.LeavesBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.phys.AABB;

import java.util.*;

/**
 * Task: Chop down trees with full cleanup and sustainability.
 *
 * Features:
 *   - Scans for ANY log type (uses BlockTags.LOGS — works for all vanilla + modded trees)
 *   - Chops ALL logs of a tree (scans upward, re-scans after each batch)
 *   - Breaks nearby leaves after logs are gone (accelerates drops, no waiting for decay)
 *   - Collects dropped items (saplings, apples, sticks) during and after chopping
 *   - Replants a matching sapling at each tree base for sustainability
 *   - Tracks tree base positions to know where to replant
 */
public class ChopTreesTask extends CompanionTask {

    private final int radius;
    private final int maxLogs;
    private final Deque<BlockPos> logTargets = new ArrayDeque<>();
    private final Deque<BlockPos> leafTargets = new ArrayDeque<>();
    private final Set<BlockPos> treeBases = new LinkedHashSet<>();
    private final Set<BlockPos> replanted = new HashSet<>();
    private BlockPos currentTarget;
    private int stuckTimer = 0;
    private int logsChopped = 0;
    private int leavesCleared = 0;
    private int saplingsPlanted = 0;
    private int scanAttempts = 0;
    private int itemSweepTimer = 0;
    private static final int MAX_SCAN_ATTEMPTS = 5;
    private static final int MAX_LEAVES_PER_TREE = 40;
    private static final int ITEM_SWEEP_INTERVAL = 40; // every 2 seconds

    private enum Phase {
        CHOPPING_LOGS,   // Primary: break all log blocks
        CLEARING_LEAVES, // Secondary: break leaves to force drops
        SWEEPING_ITEMS,  // Tertiary: collect dropped items nearby
        REPLANTING       // Final: plant saplings at tree bases
    }
    private Phase phase = Phase.CHOPPING_LOGS;

    /**
     * @param radius   Search radius for trees
     * @param maxLogs  Maximum logs to chop before stopping (0 = unlimited/within radius)
     */
    public ChopTreesTask(CompanionEntity companion, int radius, int maxLogs) {
        super(companion);
        this.radius = radius;
        this.maxLogs = maxLogs > 0 ? maxLogs : 999;
    }

    @Override
    public String getTaskName() {
        return "Chop trees (r=" + radius + ")";
    }

    @Override
    public int getProgressPercent() {
        return maxLogs > 0 ? Math.min(100, (logsChopped * 100) / maxLogs) : -1;
    }

    @Override
    protected void start() {
        scanForLogs();
        if (logTargets.isEmpty()) {
            say("No trees found nearby.");
            complete();
            return;
        }
        say("Found " + logTargets.size() + " logs to chop!");
    }

    @Override
    protected void tick() {
        // Periodic item sweep during any phase (pickup items generated by leaf decay)
        itemSweepTimer++;
        if (itemSweepTimer >= ITEM_SWEEP_INTERVAL) {
            itemSweepTimer = 0;
            sweepNearbyItems();
        }

        switch (phase) {
            case CHOPPING_LOGS -> tickChopLogs();
            case CLEARING_LEAVES -> tickClearLeaves();
            case SWEEPING_ITEMS -> tickSweepItems();
            case REPLANTING -> tickReplant();
        }
    }

    // ========== PHASE 1: Chop all logs ==========

    private void tickChopLogs() {
        if (logsChopped >= maxLogs) {
            MCAi.LOGGER.info("ChopTreesTask: reached maxLogs={}, transitioning to leaves", maxLogs);
            transitionToLeaves();
            return;
        }

        if (logTargets.isEmpty()) {
            scanAttempts++;
            if (scanAttempts > MAX_SCAN_ATTEMPTS) {
                transitionToLeaves();
                return;
            }
            scanForLogs();
            if (logTargets.isEmpty()) {
                transitionToLeaves();
                return;
            }
        }

        if (currentTarget == null) {
            currentTarget = logTargets.peek();
            stuckTimer = 0;
        }

        BlockState state = companion.level().getBlockState(currentTarget);
        if (state.isAir() || !state.is(BlockTags.LOGS)) {
            logTargets.poll();
            currentTarget = null;
            return;
        }

        if (isInReach(currentTarget, 3.5)) {
            // Track tree bases — the lowest log position is where we'll replant
            trackTreeBase(currentTarget);

            companion.equipBestToolForBlock(state);
            BlockHelper.breakBlock(companion, currentTarget);
            logTargets.poll();
            currentTarget = null;
            stuckTimer = 0;
            logsChopped++;
            if (logsChopped % 4 == 0 || logsChopped == 1) {
                MCAi.LOGGER.info("ChopTreesTask: chopped {}/{} logs, {} targets remaining",
                        logsChopped, maxLogs, logTargets.size());
            }
        } else {
            navigateTo(currentTarget);
            stuckTimer++;
            if (stuckTimer > 120) {
                MCAi.LOGGER.debug("ChopTreesTask: stuck on log at {}, skipping", currentTarget);
                logTargets.poll();
                currentTarget = null;
                stuckTimer = 0;
            }
        }
    }

    // ========== PHASE 2: Clear nearby leaves ==========

    private void transitionToLeaves() {
        phase = Phase.CLEARING_LEAVES;
        currentTarget = null;
        stuckTimer = 0;
        scanForLeaves();
        if (leafTargets.isEmpty()) {
            transitionToSweep();
        }
    }

    private void tickClearLeaves() {
        if (leafTargets.isEmpty() || leavesCleared >= MAX_LEAVES_PER_TREE * treeBases.size()) {
            transitionToSweep();
            return;
        }

        if (currentTarget == null) {
            currentTarget = leafTargets.peek();
            stuckTimer = 0;
        }

        BlockState state = companion.level().getBlockState(currentTarget);
        if (state.isAir() || !(state.getBlock() instanceof LeavesBlock)) {
            leafTargets.poll();
            currentTarget = null;
            return;
        }

        if (isInReach(currentTarget, 4.0)) {
            BlockHelper.breakBlock(companion, currentTarget);
            leafTargets.poll();
            currentTarget = null;
            stuckTimer = 0;
            leavesCleared++;
        } else {
            navigateTo(currentTarget);
            stuckTimer++;
            if (stuckTimer > 80) {
                leafTargets.poll();
                currentTarget = null;
                stuckTimer = 0;
            }
        }
    }

    // ========== PHASE 3: Final item sweep ==========

    private void transitionToSweep() {
        phase = Phase.SWEEPING_ITEMS;
        stuckTimer = 0;
    }

    private void tickSweepItems() {
        // Give items 2 seconds to settle, then do a final sweep and move to replanting
        stuckTimer++;
        if (stuckTimer > 40) {
            sweepNearbyItems();
            transitionToReplant();
        }
    }

    // ========== PHASE 4: Replant saplings ==========

    private void transitionToReplant() {
        phase = Phase.REPLANTING;
        currentTarget = null;
        stuckTimer = 0;
    }

    private void tickReplant() {
        // Find next tree base that hasn't been replanted
        if (currentTarget == null) {
            BlockPos nextBase = null;
            for (BlockPos base : treeBases) {
                if (!replanted.contains(base)) {
                    nextBase = base;
                    break;
                }
            }
            if (nextBase == null) {
                // All replanted (or no bases) — done!
                finishTask();
                return;
            }
            currentTarget = nextBase;
            stuckTimer = 0;
        }

        if (isInReach(currentTarget, 3.5)) {
            tryReplantSapling(currentTarget);
            replanted.add(currentTarget);
            currentTarget = null;
        } else {
            navigateTo(currentTarget);
            stuckTimer++;
            if (stuckTimer > 100) {
                // Can't reach — skip this base
                replanted.add(currentTarget);
                currentTarget = null;
                stuckTimer = 0;
            }
        }
    }

    // ========== Completion ==========

    private void finishTask() {
        MCAi.LOGGER.info("ChopTreesTask complete: {} logs, {} leaves, {} saplings planted, {} tree bases",
                logsChopped, leavesCleared, saplingsPlanted, treeBases.size());
        StringBuilder msg = new StringBuilder();
        msg.append("Done! Chopped ").append(logsChopped).append(" logs");
        if (leavesCleared > 0) {
            msg.append(", cleared ").append(leavesCleared).append(" leaves");
        }
        if (saplingsPlanted > 0) {
            msg.append(", replanted ").append(saplingsPlanted).append(" sapling")
               .append(saplingsPlanted > 1 ? "s" : "");
        }
        msg.append(".");
        say(msg.toString());
        complete();
    }

    @Override
    protected void cleanup() {
        logTargets.clear();
        leafTargets.clear();
        treeBases.clear();
        replanted.clear();
    }

    // ========== Scanning ==========

    private void scanForLogs() {
        logTargets.clear();
        List<BlockPos> found = BlockHelper.scanForLogs(companion, radius, maxLogs - logsChopped);
        logTargets.addAll(found);
    }

    /**
     * Scan for leaves near tree bases (orphaned leaves that will decay slowly).
     * Only scans leaves without a connected log (persistent=false, distance>=7 or no log nearby).
     */
    private void scanForLeaves() {
        leafTargets.clear();
        Level level = companion.level();
        Set<BlockPos> seen = new HashSet<>();

        for (BlockPos base : treeBases) {
            // Scan a column above each tree base for leaves
            for (int dx = -3; dx <= 3; dx++) {
                for (int dy = 0; dy <= 20; dy++) {
                    for (int dz = -3; dz <= 3; dz++) {
                        BlockPos pos = base.offset(dx, dy, dz);
                        if (seen.contains(pos)) continue;
                        seen.add(pos);

                        BlockState state = level.getBlockState(pos);
                        if (state.getBlock() instanceof LeavesBlock) {
                            // Only target non-persistent leaves (natural, not player-placed)
                            if (!state.getValue(LeavesBlock.PERSISTENT)) {
                                leafTargets.add(pos);
                            }
                        }
                    }
                }
            }
        }

        // Sort by distance
        leafTargets.stream().sorted((a, b) -> {
            double distA = companion.distanceToSqr(a.getX() + 0.5, a.getY() + 0.5, a.getZ() + 0.5);
            double distB = companion.distanceToSqr(b.getX() + 0.5, b.getY() + 0.5, b.getZ() + 0.5);
            return Double.compare(distA, distB);
        });
    }

    // ========== Tree base tracking ==========

    /**
     * Track the base of a tree being chopped. The "base" is the lowest log position
     * in a vertical column — this is where we replant.
     */
    private void trackTreeBase(BlockPos logPos) {
        // Walk down to find the lowest log in this column
        Level level = companion.level();
        BlockPos base = logPos;
        while (true) {
            BlockPos below = base.below();
            BlockState belowState = level.getBlockState(below);
            if (belowState.is(BlockTags.LOGS)) {
                base = below;
            } else {
                break;
            }
        }

        // Only track if the block below base is dirt/grass (valid planting spot)
        BlockState ground = level.getBlockState(base.below());
        if (ground.is(BlockTags.DIRT) || ground.is(Blocks.GRASS_BLOCK.defaultBlockState().getBlock())) {
            treeBases.add(base);
        }
    }

    // ========== Sapling replanting ==========

    /**
     * Attempt to replant a sapling at a tree base position.
     * Matches the sapling type to whatever sapling is in the companion's inventory.
     * Prefers the sapling that matches the original tree type, but will use any available.
     */
    private void tryReplantSapling(BlockPos base) {
        Level level = companion.level();

        // Base position should now be air (the log was chopped)
        BlockState baseState = level.getBlockState(base);
        if (!baseState.isAir() && !baseState.canBeReplaced()) return;

        // Ground below must be dirt/grass/podzol
        BlockState ground = level.getBlockState(base.below());
        if (!ground.is(BlockTags.DIRT)) return;

        // Find any sapling in companion inventory
        var inv = companion.getCompanionInventory();
        for (int i = 0; i < inv.getContainerSize(); i++) {
            ItemStack stack = inv.getItem(i);
            if (stack.isEmpty()) continue;

            Block saplingBlock = getSaplingBlock(stack.getItem());
            if (saplingBlock != null) {
                // Place the sapling
                level.setBlock(base, saplingBlock.defaultBlockState(), 3);
                stack.shrink(1);
                if (stack.isEmpty()) inv.setItem(i, ItemStack.EMPTY);
                saplingsPlanted++;
                MCAi.LOGGER.info("Replanted {} at {}", saplingBlock.getName().getString(), base);
                return;
            }
        }

        MCAi.LOGGER.debug("No saplings available to replant at {}", base);
    }

    /**
     * Map sapling items to their block form for planting.
     * Returns null if the item is not a sapling.
     */
    private static Block getSaplingBlock(Item item) {
        if (item == Items.OAK_SAPLING) return Blocks.OAK_SAPLING;
        if (item == Items.SPRUCE_SAPLING) return Blocks.SPRUCE_SAPLING;
        if (item == Items.BIRCH_SAPLING) return Blocks.BIRCH_SAPLING;
        if (item == Items.JUNGLE_SAPLING) return Blocks.JUNGLE_SAPLING;
        if (item == Items.ACACIA_SAPLING) return Blocks.ACACIA_SAPLING;
        if (item == Items.DARK_OAK_SAPLING) return Blocks.DARK_OAK_SAPLING;
        if (item == Items.CHERRY_SAPLING) return Blocks.CHERRY_SAPLING;
        if (item == Items.MANGROVE_PROPAGULE) return Blocks.MANGROVE_PROPAGULE;

        // Modded saplings: try the generic block-from-item approach
        Block block = Block.byItem(item);
        if (block != Blocks.AIR) {
            BlockState state = block.defaultBlockState();
            if (state.is(BlockTags.SAPLINGS)) {
                return block;
            }
        }
        return null;
    }

    // ========== Item collection ==========

    /**
     * Actively collect dropped items within 6 blocks of the companion.
     * Picks up saplings, apples, sticks, and any other drops from leaves/logs.
     * This supplements the CompanionPickupItemGoal which may be interrupted by task navigation.
     */
    private void sweepNearbyItems() {
        Level level = companion.level();
        AABB box = companion.getBoundingBox().inflate(6.0);
        List<ItemEntity> items = level.getEntitiesOfClass(ItemEntity.class, box,
                e -> e.isAlive() && !e.isRemoved() && !e.hasPickUpDelay());

        for (ItemEntity itemEntity : items) {
            if (companion.distanceToSqr(itemEntity) <= 2.0 * 2.0) {
                // Close enough — pick up directly
                ItemStack stack = itemEntity.getItem();
                ItemStack remainder = companion.getCompanionInventory().addItem(stack.copy());
                if (remainder.isEmpty()) {
                    companion.take(itemEntity, stack.getCount());
                    itemEntity.discard();
                } else if (remainder.getCount() < stack.getCount()) {
                    int picked = stack.getCount() - remainder.getCount();
                    companion.take(itemEntity, picked);
                    itemEntity.getItem().setCount(remainder.getCount());
                }
            }
        }
    }
}
